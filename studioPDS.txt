Client

La prima finestra visibile è MainControl.xaml
l'entry point del progetto sembra essere MainWindow (forse di default è così sempre) 
anche se la sua finestra non si vede
La MainWindow serve per creare l'oggetto MainControl e per avere il riferimento a ClientLogic.

in MainControla callback del button connect è connect_button_Click 
che istanzia ClientLogic come un TcpClient (windows.Net.Soket)
se l'indirizzo e la porta sono validi, questi controlli colorano la cornice dei box
MainWindow mw = (MainWindow)Application.Current.MainWindow ritorna l'istanza della MainWindow (tipo singletone?)
in Mainwindow il riferimento a clientLogic è PUBLIC !!
e sempre in connect_button_Click viene assegnato il riferimento a ClientLogic di MainWindow
nell'attesa della connesione viene visualizzato un progressRing -> MahApps.Metro !!

ClientLogic ha un macello di costanti -> pulire
ClientLogic è solo .cs no .xaml 
Ha un riferimento a MainWindow (vorrei capire a che serve!)
ClientLogic ha due costruttori, uno che riceve TcpClient e uno no e lo istanzia al suo interno
il primo viene chiamato dal button conneti della MainWindow
il secondo viene chiamato dalla RestoreFile
in ClientLogic la connessione è gestita da TcpClient.Connect(address, port) in un metodo asincrono
gestito da workertransaction = new BackgroundWorker() a cui si delega l'esecuzione di un task
workertransaction.DoWork += new DoWorkEventHandler(MyTask); //setta il task da eseguire
workertransaction.RunWorkerCompleted += new RunWorkerCompletedEventHandler(MyTaskCompleted);    //motodo da eseguire quando il task è compiuto
workertransaction.RunWorkerAsync(); //inizia l'esecuzione del task settato in modo asincrono

Se la connessione viene instaurata si passa il controllo a LoginRegisterControl e alla relativa Window (UserControl)
--
A window is managed by the OS and is placed on the desktop.
A UserControl is managed by wpf and is placed in a Window or in another UserControl.
Applcations could be created by have a single Window and displaying lots of UserControls in that Window.
--
LoginRegisterControl gestisce i bottoni Login, Registrati e Back collegando gli eventi alle callback adatte
Login_Click passa il controllo a LoginControl e relativa finestra di login
Registrati_Click passa il controllo a RegistratiControl e relativa finestra di registrazione
il controllo si passa con:
LoginControl main = new LoginControl(null); //istanzio l'oggetto a cui voglio passare il controllo
App.Current.MainWindow.Content = main;      //quell'oggetto diventa il content della main window

RegistratiControl invia le informazioni a ClientLogic.Registrati che provvede ad inviarle al server
l'invio è fatto tramite la ClientLogic.WriteStringOnStream(string message)
prepara i dati (converti da ASCII a byte) e invia sul canale
si attende la risposta del server con ReadStringFromStream()
che parsifica i byte letti da stream come string
Se la risposta non è OK il controllo torna a MainControl e stream e socket vengono chiusi
se la risposta è OK il controllo passa a MenuControl e l'icona e il bool connesso si aggiornano come connessi

MenuControl ha una parte backup e una restore
Entrambe hanno dei button con cui definire la cartella di backup o di restore (risp FolderButton e FolderButtonR)
Backup
Una volta settata la cartella di backup e clickato su start se ClientLogic non sta monitornado la callback EffettuaBackup_Click
invia al server FOLDER + user + path e il server può rispondere con RootFolder Inserita o Stessa RootFolder
Si inizializza la ProgressBar e si prendono i path di ciascun file nella rootdir con 
Directory.GetFiles(path, "*.*", System.IO.SearchOption.AllDirectories) //systemIO class
e si inviano al server con clientLogic.InvioFile(files);
Si inizializza quindi un FileSystemWatcher e gli si registrano le callback nei vari casi di modifica ai files
Se invece ClientLogic stava monitornado quindi cliccando sul bottone si vuole interrompere il monitoring 
si invoca la AttendiTermineUpdate che gestisce l'attesa di lavori in corso e il rilascio del watcher
In caso di eccezione un opportuno thread viene fatto eseguire
La ClientLogic.InvioFile(string[] Filenames) prepara le callback del workertransaction per l'effettivo invio dei file
il task in background è Workertransaction_InviaFile che per ogni file invoca la ClientLogic.InviaFile
nella quale tramite  clientsocket.Client.Send() si invia al server un header che lo prepara per il file che seguirà
l'header contiene: Content-length Filename Checksum. In base alla risposta del server all'header si può evitare l'invio
poi eventualmente si inviano i byte del file effettivo che viene spezzettato in base alla sua grandezza rispetto a una bufferSize
Dopo ogni InviaFile si controllano eventuali errori e si aggiorna la ProgressBar tramite la workertransaction.ReportProgress()
finiti i file si invia un messaggio di ENDSYNC + username + folder per comunicare la fine dell'invio

workertranaction_InviaFileCompleted da studiare

MahApps.Metro
I dialog box erano fighi ora si sostituiscono con i message box ?
Il progress ring si deve sostituire :(

idee
Server stampa il suo IP

FIX
se da LoginRegisterControl si torna indietro la finestra non cambia nome
autenticazione su mac -> ma se è sul mac come abbiamo fatto a connetterci dal mixto?!
autenticazione a sfida

Dubbi
Come funziona lo stream? se nessuno legge e qualcuno scrive i dati restano lì? e viceversa?
Come funziona un socket? Socket.Send(byte[] buffer)? un solo socket per canale? sincrono?
