------------
|| CLIENT ||
------------


La prima finestra visibile è MainControl.xaml
l'entry point del progetto sembra essere MainWindow (forse di default è così sempre) 
anche se la sua finestra non si vede
La MainWindow serve per creare l'oggetto MainControl e per avere il riferimento a ClientLogic.

in MainControl la callback del button connect è connect_button_Click 
che istanzia ClientLogic come un TcpClient (windows.Net.Soket)
se l'indirizzo e la porta sono validi, questi controlli colorano la cornice dei box
MainWindow mw = (MainWindow)Application.Current.MainWindow ritorna l'istanza della MainWindow (tipo singletone?)
in Mainwindow il riferimento a clientLogic è PUBLIC !!
e sempre in connect_button_Click viene assegnato il riferimento a ClientLogic di MainWindow
nell'attesa della connesione viene visualizzato un progressRing -> MahApps.Metro !!

ClientLogic ha un macello di costanti -> pulire
ClientLogic è solo .cs no .xaml 
Ha un riferimento a MainWindow (vorrei capire a che serve!)
ClientLogic ha due costruttori, uno che riceve TcpClient e uno no e lo istanzia al suo interno
il primo viene chiamato dal button connetti della MainWindow
il secondo viene chiamato dalla RestoreFile
in ClientLogic la connessione è gestita da TcpClient.Connect(address, port) in un metodo asincrono
gestito da workertransaction = new BackgroundWorker() a cui si delega l'esecuzione di un task
workertransaction.DoWork += new DoWorkEventHandler(MyTask); //setta il task da eseguire
workertransaction.RunWorkerCompleted += new RunWorkerCompletedEventHandler(MyTaskCompleted);    //motodo da eseguire quando il task è compiuto
workertransaction.RunWorkerAsync(); //inizia l'esecuzione del task settato in modo asincrono

Se la connessione viene instaurata si passa il controllo a LoginRegisterControl e alla relativa Window (UserControl)
--
A window is managed by the OS and is placed on the desktop.
A UserControl is managed by wpf and is placed in a Window or in another UserControl.
Applcations could be created by have a single Window and displaying lots of UserControls in that Window.
http://stackoverflow.com/questions/5772367/window-vs-user-control
--
LoginRegisterControl gestisce i bottoni Login, Registrati e Back collegando gli eventi alle callback adatte
Login_Click passa il controllo a LoginControl e relativa finestra di login
Registrati_Click passa il controllo a RegistratiControl e relativa finestra di registrazione
il controllo si passa con:
LoginControl main = new LoginControl(null); //istanzio l'oggetto a cui voglio passare il controllo
App.Current.MainWindow.Content = main;      //quell'oggetto diventa il content della main window

RegistratiControl invia le informazioni a ClientLogic.Registrati che provvede ad inviarle al server
l'invio è fatto tramite la ClientLogic.WriteStringOnStream(string message)
prepara i dati (converti da ASCII a byte) e invia sul canale
si attende la risposta del server con ReadStringFromStream()
che parsifica i byte letti da stream come string
Se la risposta non è OK il controllo torna a MainControl e stream e socket vengono chiusi
se la risposta è OK il controllo passa a MenuControl e l'icona e il bool connesso si aggiornano come connessi

LoginControl invia al server le credenziali passando per ClientLogic.Login e verificando la risposta si procede
passando il controllo a MenuControl oppure disconnettendo il client
FIXME: le credenziali sia in registration sia in login sono mandate in chiaro!

MenuControl ha una parte backup e una restore
Entrambe hanno dei button con cui definire la cartella di backup o di restore (risp FolderButton e FolderButtonR)

BACKUP
Una volta settata la cartella di backup e clickato su start se ClientLogic non sta monitornado la callback EffettuaBackup_Click
invia al server FOLDER + user + path e il server può rispondere con RootFolder Inserita o Stessa RootFolder
Si inizializza la ProgressBar e si prendono i path di ciascun file nella rootdir con 
Directory.GetFiles(path, "*.*", System.IO.SearchOption.AllDirectories) //systemIO class
e si inviano al server con clientLogic.InvioFile(files);
Si inizializza quindi un FileSystemWatcher e gli si registrano le callback nei vari casi di modifica ai files
i vari eventi legati al watcher sono sincronizzati su un AutoResetEvent - segnalato si passa, non segnalato stop
(superata la WaitOne() viene chiamata la Reset() implicitamente - non segnalato - si usa la Set() per segnalarlo)
Se invece ClientLogic stava monitornado quindi cliccando sul bottone si vuole interrompere il monitoring 
si invoca la AttendiTermineUpdate che gestisce l'attesa di lavori in corso e il rilascio del watcher
In caso di eccezione un opportuno thread viene fatto eseguire
La ClientLogic.InvioFile(string[] Filenames) prepara le callback del workertransaction per l'effettivo invio dei file
il task in background è Workertransaction_InviaFile che per ogni file invoca la ClientLogic.InviaFile
nella quale tramite  clientsocket.Client.Send() si invia al server una string header che lo prepara per il file che seguirà
l'header contiene: Content-length Filename Checksum. In base alla risposta del server all'header si può evitare l'invio
poi eventualmente si inviano i byte del file effettivo che viene aperto come stream e spezzettato in blocchi di byte (bufferSize)
Dopo ogni InviaFile si controllano eventuali errori e si aggiorna la ProgressBar tramite la workertransaction.ReportProgress()
finiti i file si invia un messaggio di ENDSYNC + username + folder per comunicare la fine dell'invio
la workertranaction_InviaFileCompleted gestisce l'esito dell'invio dei file in base ai valori di e.Result ed e.Cancel
il controllo torna a MainControl in caso di errori

il watcher scatena degli eventi - ciascuno in un thread diverso - se qualche file viene modificato (cancellato, rinominato, creato, cambiato) 
e più o meno i controlli in ciascuna callback sono gli stessi: 
sincronizzo, verifico estensioni problematiche, verifico di stare effettivamente monitorando
quindi invio le informazioni necessarie e/o i file al server
se vengono create directory o creati/rinominati file vuoti il server non viene informato (vedi controlli nelle varie callback)
il file viene inviato con MenuControl.InviaSingoloFile 
che fa quasi le stesso operazioni della ClienLogic.InviaFile + una gestione ad hoc della ProgressBar 
FIXME: Due classi diverse che fanno quasi la stessa cosa ?!

RESTORE
Viene istanziato un nuovo ClientLogic che aprirà un nuovo socket (quello che già c'è è riservato per il backup?)
il controllo passa a Restore che ha un .xaml non visibile come la MainWindow
Resotre nel suo costruttore istanzia RestoreUC che gestisce la finestra dalla quale scegliere cartella o file da ripristinare
la MainWindow diventa Restore che però salva un riferimento alla vecchia MainWindow
Restore gestisce la chiusura della finestra rilasciando le risorse in modo opportuno a seconda di quale classe sia la MainWindow
RestoreUC gestisce una ListBox e un Button di selezione
La ListBox viene popolata con ListBoxItem che è StackPanel con icona + folderPath per ciascuna cartella di backup memorizzata dall'utente
-invece di usare StackPanel si potrebbe usare una classe derivata da StackPanel con possibilità di ricavare facilmente la stringa-
i vari folderPath sono stati comunicati dal server come risposta al messaggio di GETFOLDERUSER
Selezionata la cartella dalla lista si salva il path corrispondente e si abilita il Button di selezione
Confermata la cartella il controllo passa a SelectActionUI che controlla tre Button: Download file, cartella e back
RESTORE FILE
download file porta il controllo a FileSelection che gestisce una ListBox navigabile e dinamica 
viene popolata opportunamente con entry relative a cartelle o file e in base al tipo di entry si linka alla ListBoxItem la callback opportuna
Si consente anche di cercare un file con un dato nome tramite una search bar ma è superfluo imho
doppiocliccando su una entry di file il controllo passa a DownloadFile che controlla una ListBox
Si popola la ListBox in base alle info sul file ricevute dal server
- info dim file = 0 -> icona file cancellato + stringa + verisone + timestamp
- info dim file > 0 -> icona file aggiunto + dim + versione + timestamp
nel secondo tipo di entry viene settata anche la callback per il doppioclick e se lo si fa si passa il controllo a StartDownload
StartDownload ha una finestra che mostra una ProgressBar 
Si occupa di farsi mandare dal server il file della versione selezionata
StartDownload.RiceviFile delega a workertransaction i task necessari per la richiesta e ricezione del file
il task in background è Workertransaction_RiceviFile che richiede al server la versione del file selezionato - comando GETFILEV
il server risponde con un header comunicandogli la dimensione del file in arrivo
quindi il client riceve pezzo per pezzo il file e lo salva in una cartella creata appositamente
terminata la ricezione si manda OK e si chiude
Alla fine del task viene eseguita la workertranaction_RiceviFileCompleted che apre l'explorer mostrando la cartella creata
RESTORE CARTELLA
Il controllo passa a DownloadFolder che da la possibilità di includere i file cancellati (CheckBox) e di iniziare il restore (Button)
la RiceviRestore comunica al RESTORE al server specificando tra i parametri se voglio o meno i file cancellati
FIXME: pur inviando i parametri al server questo non manda indietro i file cancellati
il workertransaction gestisce il lavoro come al solito
il task principale si occupa di loopare sulle risposte del server per ogni file che ha intenzione di mandare 
viene prima ricevuto un header in base al quale il client decide se vuole inviato il relativo file (controllo checksum se il file esiste già)
la ricezione del file avviene come in StartDownload 
Il loop termina quando il server manda al posto dell'header un apposito messaggio
finito il restore si apre l'explorer per mostrare quanto ripristinato


LOGOUT - inutilizzabile
Il logout è gestito una un apposito CustomDialog (Metro quindi inutilizzabile) che istanzia Disconnetti con una gestione dei controlli strana:
le callback dei suoi button vengono assegnate in MenuControl invece di stare in Disconnetti.xaml.cs
la disconnessione avviene tramite ClientLogic.DisconnettiServer 
che con callback opportune di workertransaction comunica le intenzioni al server e rilascia le risorse di rete


MahApps.Metro
I dialog box erano fighi ora si sostituiscono con i message box ? Lo stesso per i CustomDialog 
https://msdn.microsoft.com/library/aa969773(v=vs.100).aspx
http://stackoverflow.com/questions/2796470/wpf-create-a-dialog-prompt
Il progress ring si deve sostituire :(

idee
- Server stampa il suo IP
- navigazione per fare la restore su un'unica finestra in cui è visibile e accessibile tutto l'albero delle directory
a partire dalla root. Se si conferma una cartella si vuole fare la restore della cartella (+file eliminati?)
se si seleziona un file si deve poi confermare la versione. navigando sono visibili i file eliminati
- selezionare cartella restore solo dopo aver deciso cosa ripristinare
- nessuna differenza tra cartella e file nella restore (restore di sottocartelle)
- i diversi backup sono mostrati con il nome della rootdir e non con il suo fullpath
- login e registrazione con logica diversa
- togliere ricerca
- versioni delle cartelle (?)
- visualizzazione della navigazione del restore più simile a windows
http://stackoverflow.com/questions/6415037/populate-treeview-from-list-of-file-paths-in-wpf
http://www.codeproject.com/Articles/21248/A-Simple-WPF-Explorer-Tree
- usare sempre socket come stream e non Socket.Send

sicurezza
(assumiamo il server sicuro e la rete insicura)
- registrazione con invio credenziali protette da DH ?
- autenticazione a sfida -> psw in chiaro sul server ma in rete viene mandato solo hash di psw + sfida
oppure 
- autenticazione psw ripetibili -> invio hash della psw e il server conserva hash e sale

FIX
- se da LoginRegisterControl si torna indietro la finestra non cambia nome
- autenticazione su mac -> ma se è sul mac come abbiamo fatto a connetterci dal mixto?!
- autenticazione a sfida
- migliore aderenza al pattern MVC
- il client si deve disconnettere quando il server si disconnette
- pulsante back in ogni finestra 
- messaggio errore utente già loggato (?)

Dubbi
- Come funziona lo stream? se nessuno legge e qualcuno scrive i dati restano lì? e viceversa?
- usare la dimensione del buffer di 512 e/o 1024 è una scelta o è sempre bene fare così
- Come funziona un socket? Socket.Send(byte[] buffer)? un solo socket per canale? sincrono?
https://msdn.microsoft.com/en-us/library/w89fhyex(v=vs.110).aspx
http://www.codeproject.com/Articles/10649/An-Introduction-to-Socket-Programming-in-NET-using
- I controlli dei dialog andrebbero gestiti nel loro .cs ? MenuControl assegna le callback dei Button di Disconnetti
- E' possibile mettere un UserControl dentro una window (sicuramente sì) così da evitare duplicazione di codice? (Es back/home button)